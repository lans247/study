GetComponent<>()
: 해당되는 컴포넌트 가져오기

AddComponent<>()
: 해당되는 컴포넌트 추가

Component.enabled = true or false
: 컴포넌트 활성화 비활성화

transform.Translate(x, y, z)
: x,y,z만큼 이동

transform.lookat(오브젝트)
: 오브젝트를 바라봄

transform.rotation
: 해당 각도의 값을 반환
: 오일러 각, 1~-1의 값을 가짐, 오일러 각이 아니면 라디안임

trasform.rotate(벡터3)
: 해당 각도 만큼 회전

transform.localScale(벡터3)
: 각축의 벡터 배 만큼 값 조절

transform.RotateAround(중심 위치, 회전 방향, 속도)
: 물체가 특정 기준으로 회전

transform.localPosition :
: 게임 오브젝트의 상대좌표, 부모가 있을 경우, 부모로 떨어진 좌표

transform.parent 
: 게임 오브젝트의 부모 오브젝트 트랜스폼
: GetComponentInParent

transform.GetChild(int index)
: index번 자식 트랜스폼 (0번부터 시작)(transform.childCount까지)
: GetComponentInChildren


Vector3 forward : z축
Vector3 up : y축
Vector3 right : x축
: 방향 조절

Iuput.GetAxis
: 입력 값을 1~-1로 변환

Input.GetAxisRaw()
: 버튼을 누르면 1, -1, 그렇지 않으면 0
: Horizontal / 양옆
: Vertical / 위아래
: Mouse Y / 마우스 위
: Mouse X / 마우스 아래

Input.GetMouseButton
: 마우스 클릭 0이 왼쪽

input.getKey(keycode)
: 키코드 입력 체크


vector3.normalized
: 정규화 (크기가 1인 방향벡터로 전환)

vector3.magnitude
: 좌표사이의 거리 or 크기 반환(float)

Distance(vector3 a, vector3 b)
: a와 b사이의 거리

Angle(vector3 a, vector3 b)
: a와 b사이의 각도

vector3.MoveTowards(현재위치, 목표위치, 속도)
: 현재위치에서 목표위치까지 속도로 이동한 결과(벡터값)를 리턴
: 따라서 transform.position = vector3.Move... 로 사용하면 됨

vector3.lerp(vector3 a, vector3 b, t)
: a와 b사이를 t만큼 보간한 벡터 반환, 매끄러운 이동
: 1.0이면 b, 0.0이면 a
: rlerp는 원형보간
: t는 얼마나 보간하는지, 끌리는 정도



rigidbody.Addforce(벡터3, ForceMode mode = ForceMode.모드)
: 물체의 충격 주기
: Force / 연속+질량(움직임)
: Acceleration / 연속 + 질량무시
: Impulse / 불연속 + 질량(보통 충돌, 폭발)
: VelocityChange / 불연속 + 질량무시


rigidbody.AddRelativeForce(벡터3, 포스모드)
: 물체 기준 벡터로 힘주기(상대벡터)

rigidbody.AddExplosionFoce(float 폭발력, vector3 폭발위치, float 반지름, 솟구치는 힘)
: 폭발에 대한 물리처리 

rigidbody.MovePosition(벡터3)
: 위치로 이동

rigidbody.MoveRotation(벡터3)
: 회전

OnCollision : collider만, 둘중하나는 is trigger체크
OnTrigger : collider, 둘중하나는 rigidbody, is trigger체크 X




Time.deltaTime
: 프레임간 시간간격(60프레임에서 1/60)

Time.time
: 게임 시작 후, 경과 시간

Time.timeScale
: 시간이 흐르는 속도 변환
: 2.0f면 두배로 시간이 빨리 흐름
: 0.0f면 정지
: 위에 의존하는 것도 정지;

Time.fixedDeltaTime
: FixedUpdate 사이 시간
: FixedUpdate() 함수 안에서 deltatime은 동일하게 작용


#에니메이션 넣기
- 아래 관리할 애니메이터 컨트롤러 생성
- 오브젝트에 애니메이터 컴포넌트 추가
(애니메이트 컴포넌트는 파일을 오브젝트에 갖다대면 만들어짐)
- 애니메이터 컨트롤러에서 관리(추가하는 등)
- 노드에 우클릭 -> make transition으로 화살표 추가
- 왼쪽 패라미터에 조건들 추가
- 패러미터에 추가한 조건들로 화살표를 통해 움직이기.
- 이후 코드에서 animator로 컴포넌트 불러와서 수정
- SetTrigger or setInteger("이름", 값) 같은 식으로 정리
- 애니메이션을 직접 만들수도 있다. (시간 대 별로 property를 조절)

- HasExitTime
- 이 값이 진행된 이후에만 전환 발생
- 체크 해제시,  전환은 바로 진행

- Fixed Duration
- 전환이 완료되기 위해 필요한 시간 설정을 %로 할지 초(s)로 할지 설정

- Transition Duration
- 전환 발생시 전환 발생 애니메이션을 블렌딩
- 0으로 하면 (앞에 모션과 섞이지 않는다) 바로 전환이 된다.

+ animator에서 animator Override Controller를 만들 수 있다.
- 이건 애니메이터를 불러오면 오버랩 할 수 있다.
- 즉 설정한 애니메이터의 레이어 매개변수 상태의 환경을 가져오고, 다양한 애니메이션에 적용할 수 있는다는 뜻
- 예시로 무기 휘두르는 모션이 조금 씩 다르지만 체계는 같으므로 그런 방식으로 사용











#코루틴 관리
IS
같은걸로 설정해서 체크 가능

- startcoroutine에서 문자열로 호출시 시간 지연됨

- return new waituntil로 특정 조건이 충족될때까지 대기가능
이 뒤에 오는 것은 int를 받고 bool를 반환하는 람다 함수이다.
ex) yield return new waituntil( () => x >= 10); 
같은 식





#Ray로 체크
- Ray, RaycastHit, Ray함수 3개 필요

- Ray :
ray = new Ray(시작위치, 시작방향)
쏘게될 레이저 방향
보통 시작 방향은 
mainCamera.forward - (1인칭) 
Camera.main.ScreenToWorldPoint(input.mouseposition) - (2D 클릭 위치)

- RaycastHit
Ray에 맞은 오브젝트 값
보통 RaycastHit.collider.gameObject로 오브젝트로 불러오기 가능

- Ray함수
ray를 쏴서 부딪힌 물체의 값을 반환하는 함수

Physics.Raycast(레이(위치랑 방향), out 레이캐스트히트, 최대거리) - 3D
RaycastHit2D hit = Physics2D.Raycast(레이(worldPoint,Vector2.zero)) - 2D

레이에는 콤마로 구분해서 위치랑 방향이 들어가도 된다. 
if문 자체에 아예 집어넣어서 부딪혔는지 체크와 동시에 값을 할당하는 것 가능





#light 
: Directional / 현실세계 태양
: spot / spotlight
: point / 일반전구
: area / bake전용 보통 tv







#canvus
- canvus생성후 그 안에서 조절
- canvus는 스크린 크기로 조절하는 것이 좋음.

1. text
- text생성이후에 게임오브젝트 찾아서, <TextMeshProUGUI>().text로 수정하는 것이 좋음
- text_mesh_pro에서 갖고 오는거 찾기

2. image
- 체력바 등에 사용
- image를 만들고, sprite적용 이후보면 이미지타입에 filled있음.
- <image>().fillamount로 수정가능


#소리
- 소리 클립 필요 - 변환해서 가지기.

- 소리를 내는 오브젝트에 audiosource컴포넌트 필요

- 클립 등록

isplaying : 체크
clip : 현재 적용중 클립
play() : 재생


오디어믹스
create - audioMixer


#리소스 가져오기
- 에셋폴더에 Resources있음. 
- 가져올때 Resources.Load<형식, gameobject, AudioClip, Sprite, TextAsset>("위치/위치/이름");


#Scriptable오브젝트 
- 하나의 데이터를 효율적으로 관리하기 우해서 적용
- class를 ScriptableObject로 참고
- [CreateAssetMenu]를 통해서 에셋에 추가가능
- 이후 변수 설정
- 이제 다른 함수에서 클래스를 변수처럼 선언가능

퀘스트
- 정보를 스크립터블 오브젝트로 관리
- 퀘스트 매니저에서 스크립터블 오브젝트로 퀘스트를 관리한다
- 진행도나 클리어 여부는 외부에서 퀘스트 매니저 내부 checking함수를 호출(오브젝트 파괴, 아이템 습득, 대화시)하며 id와 해당되는 퀘스트 타입을 전달
- 그리고 checking함수에서 가지고 있는 퀘스트 중 해당하는 것이 있다면 진행도를 플러스 시키면 된다.










#UI
- image

- 스크롤뷰(우리가 하는 스크롤 해서 내리는 거들) - 뷰포트에 컨텐츠 넣기 가능
- content안에 VerticalLayout, contentSizeFitter넣고 넣을 내용에 대해서 설정
- 수직 방향 크기 조절을 위해서 content anchor를 위아래로 수정 가능하도록 수정
- 컨텐츠 아래로 ui를 추가하면 미리 설정한 것들이 아래로 들어감

- button
- 아래 보면 onclick창이 있음, 추가해서 실행하면 됨
- 개인적으로 button에 스크립트 추가해서 onclick함수 만들어서 하면 좋음



tilemap
- tile, tile brush 이 그전에 미리 필요
- 사진을 잘라서 타일로 만들고(multiple, pixel per unit을 128로 한 다음에 sprite editor)
- window>2D>Tile Palette에서 사진 집어 넣고 새거 만들기
- create에서 tilemap생성하면됨

- 이후 콜라이더 배치 가능 
- tilemap collider + Composite collider로 깔끔하게 만들기 가능
- 룰 타일도 존재





#미니맵 만들기
1. 인스펙터에 minimap layer추가.
2. main카메라에는 cullingmask에 minimap레이어 제외
3. 프로젝트 창에 create -> rendertexture추가
4. 미니맵 카메라 생성, 컬링마스크에 minimap레이어만 포함, 
3번에서 만든 렌더텍스쳐를 target texture에 삽입
5. UI에서 raw image를 생성, 3번에서 생성한 렌더 텍스쳐 삽입
6. 각각 오브젝트에 미니맵에서 보일 레이어들을 추가


Invoke()
시간 딜레이를 주고 함수를 시행시키는 함수

Invoke("함수이름", a);
a 시간이 지난후 함수를 시행시킨다. 

InvokeRepeating("함수 이름", a, b);
a 시간이 지난 후 함수를 시행하며, 이후 b초마다 함수를 반복 시행

CancelInvoke("함수이름");
으로 invoke함수 정지 가능, 아무것도 넣지 않으면 모두 정지

isInvoking으로 체크 가능

코루틴 보다 성능 떨어짐


#Cinemachine[

- 카메라 기능 다수
- 기본적으로 가상 카메라 여러개, 그리고 메인 카메라로 만들어지고
- 메인카메라에 있는 brain을 통해 메인 카메라가 가상 카메라로 전환되는 방식

#2D
- follow를 통해서 객체를 따라오게 설정 가능
- 아래있는 body를 통해서 조절가능
Damping : 따라오는 속도
DeadZone : 이 안에 공간에서 카메라 움직임 X
SoftZone : 이 너머로는 카메라가 즉각 적으로 이동 = 따라오는 범위의 한계

- GameWindowGuides를 활성화 하면 화면에 뜬다.
빈 화면 : 이 공간에서는 카메라 안 움직임
파란 화면 : 이 공간에서 카메라가 천천히 물체를 다라감
빨간 화면 : 이 공간에서 카메라가 즉각적으로 물체를 따라감 


Extension
- confinder 제한자, 카메라가 있을 공간을 제한 가능
- 제한될 공간에 composite or polygon 콜라이더가 필요
- 콜라이더를 isTrigger를 체크 
- 카메라 인스펙터의 Bonding shape로 옮기면 된다.



]


window -> 렌더링 -> light -> skybox가 아니라 color